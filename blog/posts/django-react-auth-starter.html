<!DOCTYPE html>
<!--
  Blog Post: I Built a Django + React Auth Starter So You Don't Have To
  Category: Web Dev
  Published: Feb 5, 2026
  Read Time: 10 min
-->
<html lang="en">
<head>
  <meta charset="UTF-8">

  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-8E198KDV00"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-8E198KDV00');
  </script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- SEO Meta Tags -->
  <title>I Built a Django + React Auth Starter So You Don't Have To | Manish Bhusal</title>
  <meta name="description" content="A production-ready Django + React authentication starter with JWT, email verification, and password reset. Clone it, configure it, ship it.">
  <meta name="keywords" content="Django authentication, React auth, JWT authentication, DRF starter, Django REST Framework, React TypeScript, full-stack auth">
  <meta name="author" content="Manish Bhusal">

  <!-- Open Graph / Social Media -->
  <meta property="og:type" content="article">
  <meta property="og:title" content="I Built a Django + React Auth Starter So You Don't Have To">
  <meta property="og:description" content="A production-ready Django + React authentication starter with JWT, email verification, and password reset.">
  <meta property="og:image" content="https://cdn.bhusalmanish.com.np/Featured%20Image/og-image-django-react-auth-starter.jpg">
  <meta property="og:url" content="https://bhusalmanish.com.np/blog/posts/django-react-auth-starter.html">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:creator" content="@maniishbhusal">
  <meta name="twitter:title" content="I Built a Django + React Auth Starter So You Don't Have To">
  <meta name="twitter:description" content="A production-ready Django + React authentication starter with JWT, email verification, and password reset.">

  <!-- Canonical URL -->
  <link rel="canonical" href="https://bhusalmanish.com.np/blog/posts/django-react-auth-starter.html">

  <!-- Schema Markup / Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "I Built a Django + React Auth Starter So You Don't Have To",
    "description": "A production-ready Django + React authentication starter with JWT, email verification, and password reset. Clone it, configure it, ship it.",
    "image": "https://cdn.bhusalmanish.com.np/Featured%20Image/og-image-django-react-auth-starter.jpg",
    "author": {
      "@type": "Person",
      "name": "Manish Bhusal",
      "url": "https://bhusalmanish.com.np"
    },
    "publisher": {
      "@type": "Person",
      "name": "Manish Bhusal"
    },
    "datePublished": "2026-02-06",
    "dateModified": "2026-02-06",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://bhusalmanish.com.np/blog/posts/django-react-auth-starter.html"
    }
  }
  </script>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Work+Sans:wght@400;500;600;700;800;900&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

  <!-- AOS Animation -->
  <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">

  <!-- Prism.js Syntax Highlighting - Tomorrow Night Theme -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">

  <!-- Main Styles -->
  <link rel="stylesheet" href="../../style.css">

  <!-- Blog Styles -->
  <link rel="stylesheet" href="../blog.css">

  <!-- Google AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1059338710816868"
     crossorigin="anonymous"></script>
</head>
<body>
  <!-- Navigation -->
  <nav class="neo-nav">
    <div class="container mx-auto px-4">
      <div class="flex justify-between items-center">
        <a href="../../index.html" class="neo-nav-logo">
          <span class="logo-letter logo-m">M</span><span class="logo-letter logo-b">B</span>
        </a>
        <div class="hidden md:flex items-center gap-2">
          <a href="../../index.html#about" class="neo-nav-link">About</a>
          <a href="../../index.html#skills" class="neo-nav-link">Skills</a>
          <a href="../../index.html#experience" class="neo-nav-link">Experience</a>
          <a href="../../index.html#projects" class="neo-nav-link">Projects</a>
          <a href="../index.html" class="neo-nav-link active">Blog</a>
          <a href="../../index.html#contact" class="btn-primary btn-small">Let's Talk</a>
        </div>
        <button id="mobile-menu-button" class="md:hidden neo-nav-link">
          <i class="fas fa-bars text-xl"></i>
        </button>
      </div>
    </div>
  </nav>

  <!-- Post Hero -->
  <section class="post-hero">
    <div class="container mx-auto px-4 max-w-4xl">
      <!-- Back to Blog -->
      <a href="../index.html" class="back-to-blog" data-aos="fade-right">
        <i class="fas fa-arrow-left"></i> Back to Blog
      </a>

      <!-- Post Meta -->
      <div class="post-meta mt-8" data-aos="fade-up">
        <span class="blog-category">Web Dev</span>
        <span class="post-meta-divider"></span>
        <span><i class="far fa-calendar"></i> Feb 6, 2026</span>
        <span class="post-meta-divider"></span>
        <span><i class="far fa-clock"></i> 15 min read</span>
      </div>

      <!-- Post Title -->
      <h1 class="post-title" data-aos="fade-up" data-aos-delay="100">
        I Built a Django + React Auth Starter So You Don't Have To
      </h1>

      <!-- Title Divider -->
      <div class="post-title-divider" data-aos="fade-up" data-aos-delay="200"></div>

      <!-- Featured Image -->
      <div class="post-featured-image" data-aos="fade-up" data-aos-delay="300">
        <img src="https://cdn.bhusalmanish.com.np/Featured%20Image/og-image-django-react-auth-starter.jpg" alt="Django + React Auth Starter - Production-ready authentication template" loading="eager">
      </div>
    </div>
  </section>

  <!-- Article Content -->
  <article class="py-8">
    <div class="container mx-auto px-4">
      <div class="article-content">

        <h2>Why I Built This</h2>

        <p>
          Every time I start a new project, the first thing I do is spend days setting up authentication. Login, signup, email verification, password reset, token refresh... it's always the same dance. And honestly? It's exhausting.
        </p>

        <p>
          I got tired of copy-pasting the same auth code from project to project. So I built a proper starter template that I can just clone and go. And since I spent the time making it production-ready, I figured someone else might find it useful too.
        </p>

        <p>
          The stack: <strong>Django 5.2 + Django REST Framework + SimpleJWT</strong> on the backend, <strong>React 19 + Vite + TypeScript</strong> on the frontend. Nothing fancy, just solid, battle-tested tools that work well together.
        </p>

        <p>
          Here's the repo: <a href="https://github.com/maniishbhusal/django-react-auth-starter" target="_blank" rel="noopener">github.com/maniishbhusal/django-react-auth-starter</a>
        </p>

        <p>
          You can check out the frontend live here: <a href="https://django-react-auth-starter.vercel.app/" target="_blank" rel="noopener">django-react-auth-starter.vercel.app</a>. The backend isn't hosted, so you can just preview the UI - but that's actually useful. You can see how clean the auth forms are and customize the landing page for your use case, whether it's a SaaS product or a personal project.
        </p>

        <figure class="post-image">
          <img src="https://cdn.bhusalmanish.com.np/Article%20Images/django-react-auth-starter/landing-page-django-starter.png" alt="AuthKit landing page - Ship Authentication in Minutes, Not Days - with Django 5, React 19, TypeScript, JWT, and PostgreSQL" loading="lazy">
          <figcaption>The starter's landing page - clean, modern, and ready to customize</figcaption>
        </figure>

        <h2>What You're Getting</h2>

        <h3>Backend (Django/DRF)</h3>

        <ul>
          <li><strong>Custom User Model</strong> - UUID primary keys (not boring auto-increment IDs) and email-based login</li>
          <li><strong>JWT Authentication</strong> - Access tokens, refresh tokens, automatic rotation</li>
          <li><strong>Email Verification</strong> - Users must verify their email before they can use the account</li>
          <li><strong>Password Reset</strong> - Secure, time-limited reset links sent via email</li>
          <li><strong>Rate Limiting</strong> - Built-in throttling so someone can't hammer your API</li>
          <li><strong>Production Security</strong> - HTTPS redirect, secure cookies, HSTS headers... all the stuff you forget to add</li>
        </ul>

        <h3>Frontend (React + Vite)</h3>

        <ul>
          <li><strong>React 19 + TypeScript</strong> - Type safety from the start</li>
          <li><strong>Auth Context + React Query</strong> - Clean state management without Redux overhead</li>
          <li><strong>Axios Interceptors</strong> - Automatic token refresh when your access token expires</li>
          <li><strong>Protected Routes</strong> - Route guards that actually handle loading states properly</li>
          <li><strong>Tailwind CSS + Radix UI</strong> - Clean, accessible UI components</li>
        </ul>

        <p>Here's what the User model looks like. Notice how email is the primary identifier, not username:</p>

        <pre><code class="language-python"># api/accounts/models.py
class User(AbstractUser):
    """Custom user model with email as the primary identifier."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    email = models.EmailField(unique=True)
    full_name = models.CharField(max_length=255, blank=True)
    agreed_to_terms = models.BooleanField(default=False)
    agreed_at = models.DateTimeField(null=True, blank=True)

    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = ["username"]</code></pre>

        <p>UUID primary keys are a small thing, but they're nicer for security (can't guess user IDs) and work better if you ever need to merge databases.</p>

        <h2>Why Djoser? (And Not Building Auth From Scratch)</h2>

        <p>This starter uses <a href="https://djoser.readthedocs.io/" target="_blank" rel="noopener">Djoser</a> for authentication endpoints. I could've built all the auth endpoints manually - registration, activation, password reset. But why? Djoser gives you battle-tested endpoints out of the box. It handles the boring stuff so you can focus on your actual app.</p>

        <p>Here's the Djoser configuration:</p>

        <pre><code class="language-python"># api/config/settings/base.py
DJOSER = {
    "LOGIN_FIELD": "email",
    "USER_CREATE_PASSWORD_RETYPE": True,
    "SET_PASSWORD_RETYPE": True,
    "PASSWORD_RESET_CONFIRM_RETYPE": True,
    "SEND_ACTIVATION_EMAIL": True,
    "SEND_CONFIRMATION_EMAIL": True,
    "ACTIVATION_URL": "activate/{uid}/{token}",
    "PASSWORD_RESET_CONFIRM_URL": "password-reset/{uid}/{token}",
    "PASSWORD_CHANGED_EMAIL_CONFIRMATION": True,
    "USERNAME_CHANGED_EMAIL_CONFIRMATION": True,
    "SERIALIZERS": {
        "user_create": "accounts.serializers.UserCreateSerializer",
        "user_create_password_retype": "accounts.serializers.UserCreateSerializer",
        "user": "accounts.serializers.UserSerializer",
        "current_user": "accounts.serializers.UserSerializer",
    },
    "EMAIL": {
        "activation": "accounts.email.ActivationEmail",
        "confirmation": "accounts.email.ConfirmationEmail",
        "password_reset": "accounts.email.PasswordResetEmail",
        "password_changed_confirmation": "accounts.email.PasswordChangedConfirmationEmail",
    },
}</code></pre>

        <p>Let me break down what each setting does:</p>

        <h3>Login &amp; Password Settings</h3>

        <ul>
          <li><code>LOGIN_FIELD: "email"</code> - Users log in with email, not username</li>
          <li><code>USER_CREATE_PASSWORD_RETYPE: True</code> - Registration requires password confirmation (password + re_password)</li>
          <li><code>SET_PASSWORD_RETYPE: True</code> - Changing password requires confirmation too</li>
          <li><code>PASSWORD_RESET_CONFIRM_RETYPE: True</code> - Same for password reset</li>
        </ul>

        <h3>Email Settings</h3>

        <ul>
          <li><code>SEND_ACTIVATION_EMAIL: True</code> - New users get an activation email</li>
          <li><code>SEND_CONFIRMATION_EMAIL: True</code> - Users get a confirmation after activation</li>
          <li><code>PASSWORD_CHANGED_EMAIL_CONFIRMATION: True</code> - Notify users when their password changes (security measure)</li>
          <li><code>USERNAME_CHANGED_EMAIL_CONFIRMATION: True</code> - Same for username/email changes</li>
        </ul>

        <h3>URL Settings</h3>

        <ul>
          <li><code>ACTIVATION_URL: "activate/{uid}/{token}"</code> - The path in email links for activation</li>
          <li><code>PASSWORD_RESET_CONFIRM_URL: "password-reset/{uid}/{token}"</code> - Path for password reset links</li>
        </ul>

        <p>These URLs get combined with <code>FRONTEND_URL</code> to create full links like <code>http://localhost:5173/activate/MQ/abc123...</code></p>

        <h3>Custom Serializers</h3>

        <p>Djoser lets you override the default serializers. I use custom ones to add fields like <code>full_name</code> and <code>agreed_to_terms</code>:</p>

        <pre><code class="language-python">"SERIALIZERS": {
    "user_create": "accounts.serializers.UserCreateSerializer",
    "user_create_password_retype": "accounts.serializers.UserCreateSerializer",
    "user": "accounts.serializers.UserSerializer",
    "current_user": "accounts.serializers.UserSerializer",
}</code></pre>

        <h3>Custom Email Classes</h3>

        <p>The default Djoser emails are plain. I override them with custom HTML templates:</p>

        <pre><code class="language-python">"EMAIL": {
    "activation": "accounts.email.ActivationEmail",
    "confirmation": "accounts.email.ConfirmationEmail",
    "password_reset": "accounts.email.PasswordResetEmail",
    "password_changed_confirmation": "accounts.email.PasswordChangedConfirmationEmail",
}</code></pre>

        <p>Each custom email class points to an HTML template and adds the <code>FRONTEND_URL</code> to the context so links go to your React app, not Django.</p>

        <blockquote>
          Djoser gives you the endpoints. SimpleJWT handles the tokens. You just wire them together and customize what you need. That's the whole point of this starter - all the wiring is already done.
        </blockquote>

        <h2>Getting Started</h2>

        <h3>Backend Setup</h3>

        <p>Clone the repo and set up the Django backend first:</p>

        <pre><code class="language-bash"># Clone it
git clone https://github.com/maniishbhusal/django-react-auth-starter.git
cd django-react-auth-starter

# Set up Python environment
cd api
python -m venv .venv

# Activate it (Windows)
.venv\Scripts\activate

# Or on Mac/Linux
source .venv/bin/activate

# Install dependencies
pip install -r requirements/dev.txt

# Set up environment variables
cp .env.example .env

# Run migrations
python manage.py migrate

# Start the server
python manage.py runserver</code></pre>

        <p>Your backend is now running at <code>http://localhost:8000</code>.</p>

        <p>Here's the thing that makes local development painless - the development settings use SQLite (no database setup needed) and a console email backend (emails print to your terminal instead of actually sending). Zero external dependencies to get started:</p>

        <pre><code class="language-python"># api/config/settings/development.py
DEBUG = True

ALLOWED_HOSTS = ["localhost", "127.0.0.1"]

# Use SQLite for local development
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": str(BASE_DIR / "db.sqlite3"),
    }
}

CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]

# Email: Use console backend for local development (prints to terminal)
EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"</code></pre>

        <p>When you register a new user, you'll see the activation email printed right in your terminal. No need to set up Mailgun or SendGrid just to test.</p>

        <blockquote>
          <strong>Gotcha:</strong> The console email uses quoted-printable encoding, which breaks long URLs with <code>=</code> and line breaks. If clicking the activation link fails, manually reconstruct the URL by removing <code>=</code> at line ends and joining the parts. Or just grab the <code>uid</code> and <code>token</code> from the URL and test directly in Swagger: <code>POST /api/v1/auth/users/activation/</code> with <code>{"uid": "...", "token": "..."}</code>.
        </blockquote>

        <h3>Frontend Setup</h3>

        <p>Open a new terminal (keep the backend running) and set up React:</p>

        <pre><code class="language-bash"># From the project root
cd web

# Install dependencies
npm install

# Set up environment
cp .env.example .env

# Start dev server
npm run dev</code></pre>

        <p>Frontend runs at <code>http://localhost:5173</code>. The only environment variable you need is the API URL:</p>

        <pre><code class="language-bash"># web/.env
VITE_API_URL=http://localhost:8000</code></pre>

        <p>Both servers need to run at the same time. Backend on 8000, frontend on 5173. CORS is already configured to allow this.</p>

        <h2>API Endpoints &amp; Swagger Documentation</h2>

        <p>The backend comes with auto-generated API documentation using drf-spectacular. In development mode, you get both Swagger UI and ReDoc:</p>

        <ul>
          <li><strong>Swagger UI:</strong> <code>http://localhost:8000/api/docs/</code></li>
          <li><strong>ReDoc:</strong> <code>http://localhost:8000/api/redoc/</code></li>
          <li><strong>OpenAPI Schema:</strong> <code>http://localhost:8000/api/schema/</code></li>
        </ul>

        <img src="https://cdn.bhusalmanish.com.np/Article%20Images/django-react-auth-starter/swagger-django-react.png" alt="Swagger UI showing all authentication endpoints for Django + React Auth API" loading="lazy">

        <p>The documentation is only available when <code>DEBUG=True</code>. In production, these routes are hidden:</p>

        <pre><code class="language-python"># api/config/urls.py
from django.conf import settings
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path("admin/", admin.site.urls),
    # Auth endpoints (Djoser)
    path("api/v1/auth/", include("djoser.urls")),
    path("api/v1/auth/", include("djoser.urls.jwt")),
    # API endpoints
    path("api/v1/", include("accounts.urls")),
]

# API Documentation - only available in DEBUG mode
if settings.DEBUG:
    from drf_spectacular.views import (
        SpectacularAPIView,
        SpectacularRedocView,
        SpectacularSwaggerView,
    )

    urlpatterns += [
        path("api/schema/", SpectacularAPIView.as_view(), name="schema"),
        path(
            "api/docs/",
            SpectacularSwaggerView.as_view(url_name="schema"),
            name="swagger-ui",
        ),
        path(
            "api/redoc/",
            SpectacularRedocView.as_view(url_name="schema"),
            name="redoc",
        ),
    ]</code></pre>

        <h3>Available Endpoints</h3>

        <p>All auth endpoints are prefixed with <code>/api/v1/auth/</code>. Here's the frontend API layer that shows every endpoint used:</p>

        <pre><code class="language-typescript">// web/src/lib/auth-api.ts
import { apiClient } from "./api-client"
import type {
  RegisterRequest,
  RegisterResponse,
  LoginRequest,
  LoginResponse,
  ActivateRequest,
  ResendActivationRequest,
  ForgotPasswordRequest,
  ResetPasswordRequest,
  RefreshTokenRequest,
  RefreshTokenResponse,
  User,
} from "@/types/auth"

// POST /api/v1/auth/users/
export async function register(
  data: RegisterRequest
): Promise&lt;RegisterResponse&gt; {
  const response = await apiClient.post&lt;RegisterResponse&gt;("/auth/users/", data)
  return response.data
}

// POST /api/v1/auth/jwt/create/
export async function login(data: LoginRequest): Promise&lt;LoginResponse&gt; {
  const response = await apiClient.post&lt;LoginResponse&gt;(
    "/auth/jwt/create/",
    data
  )
  return response.data
}

// POST /api/v1/auth/jwt/refresh/
export async function refreshToken(
  data: RefreshTokenRequest
): Promise&lt;RefreshTokenResponse&gt; {
  const response = await apiClient.post&lt;RefreshTokenResponse&gt;(
    "/auth/jwt/refresh/",
    data
  )
  return response.data
}

// POST /api/v1/auth/users/activation/
export async function activate(data: ActivateRequest): Promise&lt;void&gt; {
  await apiClient.post("/auth/users/activation/", data)
}

// POST /api/v1/auth/users/resend_activation/
export async function resendActivation(
  data: ResendActivationRequest
): Promise&lt;void&gt; {
  await apiClient.post("/auth/users/resend_activation/", data)
}

// POST /api/v1/auth/users/reset_password/
export async function forgotPassword(
  data: ForgotPasswordRequest
): Promise&lt;void&gt; {
  await apiClient.post("/auth/users/reset_password/", data)
}

// POST /api/v1/auth/users/reset_password_confirm/
export async function resetPassword(data: ResetPasswordRequest): Promise&lt;void&gt; {
  await apiClient.post("/auth/users/reset_password_confirm/", data)
}

// GET /api/v1/auth/users/me/
export async function getMe(): Promise&lt;User&gt; {
  const response = await apiClient.get&lt;User&gt;("/auth/users/me/")
  return response.data
}</code></pre>

        <h3>Request &amp; Response Types</h3>

        <p>Every endpoint is fully typed. Here are the TypeScript interfaces that match the API:</p>

        <pre><code class="language-typescript">// web/src/types/auth.ts
export interface User {
  id: string
  email: string
  full_name: string
  agreed_to_terms: boolean
  agreed_at: string | null
  date_joined: string
}

export interface RegisterRequest {
  email: string
  username: string
  password: string
  re_password: string
  full_name: string
  agreed_to_terms: boolean
}

export interface RegisterResponse {
  id: string
  email: string
  full_name: string
}

export interface LoginRequest {
  email: string
  password: string
}

export interface LoginResponse {
  access: string
  refresh: string
}

export interface ActivateRequest {
  uid: string
  token: string
}

export interface ResendActivationRequest {
  email: string
}

export interface ForgotPasswordRequest {
  email: string
}

export interface ResetPasswordRequest {
  uid: string
  token: string
  new_password: string
  re_new_password: string
}

export interface RefreshTokenRequest {
  refresh: string
}

export interface RefreshTokenResponse {
  access: string
  refresh: string
}

export interface ApiError {
  [key: string]: string[] | string
}</code></pre>

        <p>For authenticated endpoints, include the JWT token in the header:</p>

        <pre><code class="language-bash">Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...</code></pre>

        <p>
          <strong>Pro tip:</strong> Use Swagger UI to test endpoints directly in the browser. Click the "Authorize" button, paste your access token, and you can test authenticated endpoints without Postman.
        </p>

        <h2>How the Auth Actually Works</h2>

        <h3>The JWT Dance</h3>

        <p>When a user logs in, they get two tokens:</p>

        <ul>
          <li><strong>Access token</strong> - Short-lived (60 minutes). This is what you send with every API request.</li>
          <li><strong>Refresh token</strong> - Long-lived (7 days). Used to get a new access token when the old one expires.</li>
        </ul>

        <p>Here's the JWT configuration on the backend:</p>

        <pre><code class="language-python"># api/config/settings/base.py
SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=60),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=7),
    "ROTATE_REFRESH_TOKENS": True,
    "BLACKLIST_AFTER_ROTATION": True,
}</code></pre>

        <p>The <code>ROTATE_REFRESH_TOKENS</code> setting is important. Every time you use the refresh token to get a new access token, you also get a new refresh token. The old refresh token gets blacklisted. This way, if someone steals your refresh token, it'll only work once.</p>

        <p>But here's where the frontend magic happens. You don't want to manually check if tokens are expired and refresh them. That's tedious. Instead, we use Axios interceptors to do it automatically:</p>

        <pre><code class="language-typescript">// web/src/lib/api-client.ts
let isRefreshing = false
let failedQueue: Array&lt;{
  resolve: (token: string) =&gt; void
  reject: (error: unknown) =&gt; void
}&gt; = []

const processQueue = (error: unknown, token: string | null = null) =&gt; {
  failedQueue.forEach((prom) =&gt; {
    if (error) {
      prom.reject(error)
    } else if (token) {
      prom.resolve(token)
    }
  })
  failedQueue = []
}

apiClient.interceptors.response.use(
  (response) =&gt; response,
  async (error: AxiosError) =&gt; {
    const originalRequest = error.config as InternalAxiosRequestConfig &amp; {
      _retry?: boolean
    }

    // If error is 401 and we haven't retried yet
    if (error.response?.status === 401 &amp;&amp; !originalRequest._retry) {
      if (isRefreshing) {
        // Queue the request while refreshing
        return new Promise((resolve, reject) =&gt; {
          failedQueue.push({ resolve, reject })
        })
          .then((token) =&gt; {
            originalRequest.headers.Authorization = `Bearer ${token}`
            return apiClient(originalRequest)
          })
          .catch((err) =&gt; Promise.reject(err))
      }

      originalRequest._retry = true
      isRefreshing = true

      const tokens = getStoredTokens()
      if (!tokens?.refresh) {
        clearStoredTokens()
        isRefreshing = false
        return Promise.reject(error)
      }

      try {
        const response = await axios.post(`${API_URL}/auth/jwt/refresh/`, {
          refresh: tokens.refresh,
        })

        const newTokens = {
          access: response.data.access,
          refresh: response.data.refresh || tokens.refresh,
        }
        setStoredTokens(newTokens)

        processQueue(null, newTokens.access)
        originalRequest.headers.Authorization = `Bearer ${newTokens.access}`

        return apiClient(originalRequest)
      } catch (refreshError) {
        processQueue(refreshError, null)
        clearStoredTokens()
        return Promise.reject(refreshError)
      } finally {
        isRefreshing = false
      }
    }

    return Promise.reject(error)
  }
)</code></pre>

        <p>The part that confused me at first was the queue. Why do we need it?</p>

        <p>Imagine this: your access token expires, and your app makes 5 API calls at almost the same time. Without the queue, all 5 would try to refresh the token simultaneously, creating a race condition mess. With the queue, the first request triggers a refresh, and the other 4 wait patiently. Once the refresh completes, all 5 requests retry with the new token.</p>

        <blockquote>
          The queue pattern is one of those things that seems over-engineered until you hit the race condition bug in production. Then you're very grateful it's there.
        </blockquote>

        <h3>Understanding "Remember Me" in JWT Authentication</h3>

        <p>A common feature in login forms is the "Remember Me" checkbox. The implementation uses different browser storage types based on the user's preference:</p>

        <figure class="post-image">
          <img src="https://cdn.bhusalmanish.com.np/Article%20Images/django-react-auth-starter/remember-me-login.png" alt="Login form with Remember Me checkbox, email and password fields" loading="lazy">
          <figcaption>The login form with "Remember Me" checkbox</figcaption>
        </figure>

        <ul>
          <li><strong>Session Storage</strong> ("Remember Me" unchecked) - Data persists only for the current tab. Open a new tab? Empty storage. Close the browser? Gone.</li>
          <li><strong>Local Storage</strong> ("Remember Me" checked) - Data persists across all tabs and survives browser restarts. You stay logged in until you explicitly log out.</li>
        </ul>

        <p>Here's how we handle token storage based on user preference:</p>

        <pre><code class="language-typescript">// web/src/lib/api-client.ts
const TOKEN_KEY = "auth_tokens"
const STORAGE_TYPE_KEY = "auth_storage_type"

export function setStoredTokens(
  tokens: StoredTokens,
  rememberMe: boolean = true
): void {
  // Clear from both storages first
  localStorage.removeItem(TOKEN_KEY)
  sessionStorage.removeItem(TOKEN_KEY)

  // Store based on rememberMe preference
  if (rememberMe) {
    localStorage.setItem(STORAGE_TYPE_KEY, "local")
    localStorage.setItem(TOKEN_KEY, JSON.stringify(tokens))
  } else {
    localStorage.setItem(STORAGE_TYPE_KEY, "session")
    sessionStorage.setItem(TOKEN_KEY, JSON.stringify(tokens))
  }
}</code></pre>

        <p><strong>When "Remember Me" is unchecked:</strong></p>
        <ul>
          <li>Tab 1 (logged in): Token in sessionStorage → Dashboard works</li>
          <li>Tab 2 (new tab): sessionStorage is empty → Redirects to login</li>
          <li>Hard refresh in Tab 1: Same sessionStorage → Still works</li>
          <li>Close browser: Token is gone → Must log in again</li>
        </ul>

        <p><strong>When "Remember Me" is checked:</strong></p>
        <ul>
          <li>All tabs share the token from localStorage</li>
          <li>Browser restart: Still logged in</li>
        </ul>

        <h3>Common Pitfall: Token Refresh Bug</h3>

        <p>Watch out for this bug in the token refresh interceptor:</p>

        <pre><code class="language-typescript">// ❌ BUG: Missing rememberMe parameter
setStoredTokens(newTokens)  // Defaults to rememberMe=true!

// ✅ FIX: Preserve the user's storage preference
const storageType = localStorage.getItem(STORAGE_TYPE_KEY)
const rememberMe = storageType === "local"
setStoredTokens(newTokens, rememberMe)</code></pre>

        <p>Without this fix, when a token refreshes, it will always store in localStorage regardless of the user's original "Remember Me" choice. This means a user who unchecked "Remember Me" would suddenly have persistent sessions after their first token refresh.</p>

        <p>
          <strong>Debugging Tip:</strong> If tokens appear in unexpected storage, open DevTools → Application tab. Check both Local Storage and Session Storage for "auth_tokens". Look at "auth_storage_type" to see what preference was set.
        </p>

        <h2>State Management with TanStack React Query</h2>

        <p>I used to reach for Redux for everything. Then I realized most of my "state" was just server data - user info, API responses, stuff like that. TanStack React Query handles this way better.</p>

        <p>The setup is minimal. In the entry point, we wrap the app with QueryClientProvider:</p>

        <pre><code class="language-typescript">// web/src/main.tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query"

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      staleTime: 5 * 60 * 1000, // 5 minutes
    },
  },
})

createRoot(document.getElementById("root")!).render(
  &lt;StrictMode&gt;
    &lt;QueryClientProvider client={queryClient}&gt;
      &lt;BrowserRouter&gt;
        &lt;AuthProvider&gt;
          &lt;App /&gt;
          &lt;Toaster position="top-right" richColors /&gt;
        &lt;/AuthProvider&gt;
      &lt;/BrowserRouter&gt;
    &lt;/QueryClientProvider&gt;
  &lt;/StrictMode&gt;
)</code></pre>

        <p>For auth operations, I created custom hooks using <code>useMutation</code>. Each hook handles one specific action - login, register, activate, password reset, etc:</p>

        <pre><code class="language-typescript">// web/src/hooks/use-auth-mutations.ts
import { useMutation } from "@tanstack/react-query"
import { AxiosError } from "axios"
import {
  register,
  login as loginApi,
  activate,
  resendActivation,
  forgotPassword,
  resetPassword,
} from "@/lib/auth-api"
import { useAuth } from "@/hooks/use-auth"
import type {
  RegisterRequest,
  RegisterResponse,
  LoginRequest,
  LoginResponse,
  ActivateRequest,
  ResendActivationRequest,
  ForgotPasswordRequest,
  ResetPasswordRequest,
  ApiError,
} from "@/types/auth"

export function useRegister() {
  return useMutation&lt;RegisterResponse, AxiosError&lt;ApiError&gt;, RegisterRequest&gt;({
    mutationFn: register,
  })
}

interface LoginMutationVariables extends LoginRequest {
  rememberMe?: boolean
}

export function useLogin() {
  const { login } = useAuth()

  return useMutation&lt;
    LoginResponse,
    AxiosError&lt;ApiError&gt;,
    LoginMutationVariables
  &gt;({
    mutationFn: ({ email, password }) =&gt; loginApi({ email, password }),
    onSuccess: async (data, variables) =&gt; {
      await login(
        {
          access: data.access,
          refresh: data.refresh,
        },
        variables.rememberMe ?? true
      )
    },
  })
}

export function useActivate() {
  return useMutation&lt;void, AxiosError&lt;ApiError&gt;, ActivateRequest&gt;({
    mutationFn: activate,
  })
}

export function useResendActivation() {
  return useMutation&lt;void, AxiosError&lt;ApiError&gt;, ResendActivationRequest&gt;({
    mutationFn: resendActivation,
  })
}

export function useForgotPassword() {
  return useMutation&lt;void, AxiosError&lt;ApiError&gt;, ForgotPasswordRequest&gt;({
    mutationFn: forgotPassword,
  })
}

export function useResetPassword() {
  return useMutation&lt;void, AxiosError&lt;ApiError&gt;, ResetPasswordRequest&gt;({
    mutationFn: resetPassword,
  })
}</code></pre>

        <p>The beauty of this approach? Each mutation gives you <code>isPending</code>, <code>isError</code>, <code>error</code>, and <code>isSuccess</code> states for free. The type generics like <code>useMutation&lt;RegisterResponse, AxiosError&lt;ApiError&gt;, RegisterRequest&gt;</code> ensure full type safety - you get autocomplete for both the request and response.</p>

        <p>The <code>useLogin</code> hook is special. Notice how it integrates with AuthContext - on success, it calls <code>login()</code> which stores the tokens and fetches the user data.</p>

        <p>When the user logs out, we clear the React Query cache to remove any cached user data:</p>

        <pre><code class="language-typescript">// web/src/context/AuthContext.tsx
import { useQueryClient } from "@tanstack/react-query"

const queryClient = useQueryClient()

const logout = useCallback(() =&gt; {
  clearStoredTokens()
  setUser(null)
  queryClient.clear()
}, [queryClient])</code></pre>

        <p>The <code>staleTime: 5 * 60 * 1000</code> setting means data is considered fresh for 5 minutes. During that time, if you navigate away and come back, React Query serves the cached data instantly instead of hitting the API again. Small thing, but it makes the app feel snappy.</p>

        <blockquote>
          React Query for API calls and caching, React Context for auth state. That's it. No Redux, no Zustand, no complexity. Sometimes less really is more.
        </blockquote>

        <h2>Protecting Your Routes</h2>

        <p>The starter includes two route guard components: <code>ProtectedRoute</code> and <code>GuestRoute</code>.</p>

        <p>ProtectedRoute is for pages that require authentication (like a dashboard). GuestRoute is the opposite - for pages that only non-authenticated users should see (like login/signup).</p>

        <pre><code class="language-typescript">// web/src/components/auth/ProtectedRoute.tsx
import { Navigate, useLocation } from "react-router-dom"
import { useAuth } from "@/hooks/use-auth"

interface ProtectedRouteProps {
  children: React.ReactNode
}

export function ProtectedRoute({ children }: ProtectedRouteProps) {
  const { isAuthenticated, isLoading } = useAuth()
  const location = useLocation()

  if (isLoading) {
    return (
      &lt;div className="flex min-h-screen items-center justify-center"&gt;
        &lt;div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent" /&gt;
      &lt;/div&gt;
    )
  }

  if (!isAuthenticated) {
    // Redirect to login, but save the attempted url
    return &lt;Navigate to="/login" state={{ from: location }} replace /&gt;
  }

  return &lt;&gt;{children}&lt;/&gt;
}</code></pre>

        <p>The loading state is important. Without it, you get a flash of the login page even when the user is authenticated - just because the auth check hasn't completed yet. Looks janky.</p>

        <p>Also notice how we save <code>location</code> in the redirect state. After the user logs in, we can send them back to where they were trying to go, not just dump them on the homepage.</p>

        <p>Usage in your routes is straightforward:</p>

        <pre><code class="language-typescript">// web/src/App.tsx
&lt;Route
  path="/dashboard"
  element={
    &lt;ProtectedRoute&gt;
      &lt;DashboardPage /&gt;
    &lt;/ProtectedRoute&gt;
  }
/&gt;</code></pre>

        <p>Here's what the dashboard looks like when a user is logged in:</p>

        <figure class="post-image">
          <img src="https://cdn.bhusalmanish.com.np/Article%20Images/django-react-auth-starter/loggedin-ui-dashboard.png" alt="Dashboard showing logged-in user with welcome message and email display" loading="lazy">
          <figcaption>The starter dashboard - customize this for your application</figcaption>
        </figure>

        <p>This is just a minimal starter dashboard to show the auth is working. You'll want to replace it with your actual app content - user settings, data visualizations, whatever your app needs. The important parts (auth context, protected routes) are already wired up and ready.</p>

        <h2>The Email Verification Flow</h2>

        <p>When a user registers, they can't log in immediately. They need to click a verification link in their email first. This prevents spam accounts and ensures the email is real.</p>

        <p>The flow works like this:</p>

        <ol>
          <li>User registers via the React signup form</li>
          <li>Django creates the user (inactive) and generates a unique token</li>
          <li>Django sends an email with a link like: <code>https://yourapp.com/activate/{uid}/{token}</code></li>
          <li>User clicks the link, which opens your React app</li>
          <li>React app calls the Django activation endpoint with the uid and token</li>
          <li>Django activates the user</li>
        </ol>

        <p>The tricky part is making sure email links point to your React frontend, not Django. That's what the custom email classes handle:</p>

        <pre><code class="language-python"># api/accounts/email.py
class ActivationEmail(BaseActivationEmail):
    """Custom activation email with frontend URL."""

    template_name = "accounts/email/activation.html"

    def get_context_data(self) -&gt; dict:
        """Add frontend URL to context."""
        context = super().get_context_data()
        context["frontend_url"] = settings.FRONTEND_URL
        context["activation_url"] = (
            f"{settings.FRONTEND_URL}/activate/{context['uid']}/{context['token']}"
        )
        context["site_name"] = "Your App"
        return context</code></pre>

        <p>The <code>FRONTEND_URL</code> setting in your <code>.env</code> file controls where these links point. In development it's <code>http://localhost:5173</code>, in production it's your actual domain.</p>

        <h2>Taking It to Production</h2>

        <p>The starter includes separate settings files for development and production. Here's what the production security settings look like:</p>

        <pre><code class="language-python"># api/config/settings/production.py
DEBUG = False

# Security
SECURE_SSL_REDIRECT = True
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
SECURE_CONTENT_TYPE_NOSNIFF = True
X_FRAME_OPTIONS = "DENY"</code></pre>

        <p>All the security headers you need but always forget to add. HSTS forces HTTPS, secure cookies prevent session hijacking over HTTP, X-Frame-Options blocks clickjacking attacks.</p>

        <h3>Production Checklist</h3>

        <p>Before you deploy, make sure you:</p>

        <ul>
          <li>Switch <code>DJANGO_SETTINGS_MODULE</code> to <code>config.settings.production</code></li>
          <li>Set up PostgreSQL (not SQLite)</li>
          <li>Configure a real email provider (Resend, SendGrid, AWS SES, etc.)</li>
          <li>Set <code>ALLOWED_HOSTS</code> to your domain</li>
          <li>Set <code>CORS_ALLOWED_ORIGINS</code> to your frontend domain</li>
          <li>Generate a strong <code>SECRET_KEY</code> (don't use the example one!)</li>
          <li>Set up proper environment variables (don't commit secrets)</li>
        </ul>

        <p>For a complete production deployment guide with Docker, Nginx, and free SSL, check out my other post: <a href="deploy-drf-production.html">Deploy Django REST Framework to Production</a>.</p>

        <p>The <code>.env.example</code> file shows you everything you need to configure:</p>

        <pre><code class="language-bash"># api/.env.example
DJANGO_SETTINGS_MODULE=config.settings.development
SECRET_KEY=your-super-secret-key-change-in-production
DEBUG=True

# Database (PostgreSQL for production)
DB_NAME=authdb
DB_USER=postgres
DB_PASSWORD=your-database-password
DB_HOST=localhost
DB_PORT=5432

# Email (SMTP)
EMAIL_HOST=smtp.resend.com
EMAIL_PORT=587
EMAIL_USE_TLS=True
EMAIL_HOST_USER=resend
EMAIL_HOST_PASSWORD=your-resend-api-key
DEFAULT_FROM_EMAIL=noreply@example.com

# Frontend URL (for email links)
FRONTEND_URL=http://localhost:5173</code></pre>

        <h2>Tests Included</h2>

        <p>The backend includes a solid test suite using pytest. Tests cover registration, JWT token flow, user profile, and the model itself.</p>

        <p>Run them with:</p>

        <pre><code class="language-bash">cd api
pytest</code></pre>

        <p>The test fixtures make it easy to write new tests:</p>

        <pre><code class="language-python"># api/conftest.py provides:
# - api_client: Unauthenticated API client
# - authenticated_client: Client with valid JWT
# - user: An active test user
# - inactive_user: A user who hasn't activated yet
# - user_data: Valid registration data</code></pre>

        <p>Here's what a test looks like:</p>

        <pre><code class="language-python"># api/accounts/tests/test_registration.py
@pytest.mark.django_db
class TestUserRegistration:
    url = "/api/v1/auth/users/"

    def test_register_user_success(self, api_client: APIClient, user_data: dict):
        response = api_client.post(self.url, user_data, format="json")
        assert response.status_code == status.HTTP_201_CREATED
        assert response.data["email"] == user_data["email"]
        assert "password" not in response.data</code></pre>

        <p>Nothing fancy, just straightforward tests that verify the API works as expected.</p>

        <h2>What's Next?</h2>

        <p>This starter gives you a solid authentication foundation. But there's always more you could add:</p>

        <ul>
          <li><strong>Social Authentication</strong> - Google, GitHub, etc. (django-allauth integrates well)</li>
          <li><strong>Two-Factor Authentication</strong> - TOTP or SMS-based 2FA</li>
          <li><strong>User Profile Management</strong> - Avatar upload, profile editing</li>
          <li><strong>Admin Dashboard</strong> - User management interface</li>
        </ul>

        <p>But that's the point of a starter - it gives you the basics so you can focus on building the actual features of your app, not reimplementing auth for the hundredth time.</p>

        <p>Clone it, customize it, ship it. And if you find bugs or have improvements, PRs are welcome: <a href="https://github.com/maniishbhusal/django-react-auth-starter" target="_blank" rel="noopener">github.com/maniishbhusal/django-react-auth-starter</a></p>

        <p>Now go build something cool. And when you do, I'd love to hear about it.</p>

        <hr>

        <p><em>Questions? Hit me up on Twitter: <a href="https://twitter.com/maniishbhusal" target="_blank" rel="noopener">@maniishbhusal</a></em></p>

        <!-- Author Bio -->
        <div class="author-bio">
          <img src="https://cdn.bhusalmanish.com.np/Landing%20Page/manish-bhusal-image.jpeg" alt="Manish Bhusal" class="author-avatar" loading="lazy">
          <div class="author-info">
            <h4>Manish Bhusal</h4>
            <p>Software Developer from Nepal. 3x Hackathon Winner. Building digital products and learning in public.</p>
            <div class="author-links">
              <a href="https://github.com/maniishbhusal" target="_blank"><i class="fab fa-github"></i></a>
              <a href="https://linkedin.com/in/maniishbhusal" target="_blank"><i class="fab fa-linkedin"></i></a>
              <a href="https://x.com/maniishbhusal" target="_blank"><i class="fab fa-x-twitter"></i></a>
            </div>
          </div>
        </div>

      </div>
    </div>
  </article>

  <!-- Related Posts -->
  <section class="related-posts bg-gray-50">
    <div class="container mx-auto px-4">
      <h3 data-aos="fade-up">Related Posts</h3>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-4xl mx-auto">

        <!-- Related Post 1 -->
        <article class="blog-card" data-aos="fade-up" data-aos-delay="100">
          <a href="deploy-drf-production.html">
            <div class="blog-card-header">
              <span class="blog-category">DevOps</span>
              <span class="blog-read-time"><i class="far fa-clock"></i> 14 min</span>
            </div>
            <div class="blog-card-body">
              <h2 class="blog-card-title">Deploy Django REST Framework to Production: Docker, Nginx, SSL</h2>
              <p class="blog-card-excerpt">
                The complete guide to deploying DRF on a VPS with Docker, PostgreSQL, Nginx, and free SSL.
              </p>
            </div>
            <div class="blog-card-footer">
              <span class="blog-date"><i class="far fa-calendar"></i> Feb 1, 2026</span>
              <span class="blog-read-more">Read <i class="fas fa-arrow-right"></i></span>
            </div>
          </a>
        </article>

        <!-- Related Post 2 -->
        <article class="blog-card" data-aos="fade-up" data-aos-delay="200">
          <a href="france-django-lasuite.html">
            <div class="blog-card-header">
              <span class="blog-category">Web Dev</span>
              <span class="blog-read-time"><i class="far fa-clock"></i> 6 min</span>
            </div>
            <div class="blog-card-body">
              <h2 class="blog-card-title">France Is Building Its Own Google Workspace — With Django</h2>
              <p class="blog-card-excerpt">
                The French government is replacing Microsoft and Google with open-source Django apps. Here's why this matters.
              </p>
            </div>
            <div class="blog-card-footer">
              <span class="blog-date"><i class="far fa-calendar"></i> Jan 31, 2026</span>
              <span class="blog-read-more">Read <i class="fas fa-arrow-right"></i></span>
            </div>
          </a>
        </article>

      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer class="neo-footer">
    <div class="container mx-auto px-4 py-8 text-center">
      <a href="../../index.html" class="neo-nav-logo inline-block mb-4">
        <span class="logo-letter logo-m">M</span><span class="logo-letter logo-b">B</span>
      </a>
      <p class="mb-4">&copy; 2026 Manish Bhusal. All rights reserved.</p>
      <div class="flex justify-center gap-4">
        <a href="https://github.com/maniishbhusal" target="_blank" class="social-link">
          <i class="fab fa-github"></i>
        </a>
        <a href="https://linkedin.com/in/maniishbhusal" target="_blank" class="social-link">
          <i class="fab fa-linkedin"></i>
        </a>
        <a href="https://x.com/maniishbhusal" target="_blank" class="social-link">
          <i class="fab fa-x-twitter"></i>
        </a>
      </div>
    </div>
  </footer>

  <!-- Mobile Menu -->
  <div id="mobile-menu" class="mobile-menu">
    <div class="p-6">
      <button id="close-menu" class="absolute top-4 right-4 neo-nav-link">
        <i class="fas fa-times text-xl"></i>
      </button>
      <nav class="mt-12">
        <a href="../../index.html#about" class="mobile-menu-link">About</a>
        <a href="../../index.html#skills" class="mobile-menu-link">Skills</a>
        <a href="../../index.html#experience" class="mobile-menu-link">Experience</a>
        <a href="../../index.html#projects" class="mobile-menu-link">Projects</a>
        <a href="../index.html" class="mobile-menu-link">Blog</a>
        <a href="../../index.html#contact" class="mobile-menu-link">Contact</a>
      </nav>
    </div>
  </div>

  <!-- Prism.js Syntax Highlighting -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-docker.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-nginx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>

  <!-- Scripts -->
  <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
  <script>
    // Initialize AOS
    AOS.init({
      duration: 400,
      once: true,
      offset: 50,
      easing: 'ease-out'
    });

    // Mobile Menu
    const mobileMenuButton = document.getElementById('mobile-menu-button');
    const mobileMenu = document.getElementById('mobile-menu');
    const closeMenu = document.getElementById('close-menu');

    mobileMenuButton.addEventListener('click', () => {
      mobileMenu.classList.add('active');
    });

    closeMenu.addEventListener('click', () => {
      mobileMenu.classList.remove('active');
    });

    document.querySelectorAll('.mobile-menu-link').forEach(link => {
      link.addEventListener('click', () => {
        mobileMenu.classList.remove('active');
      });
    });
  </script>
</body>
</html>
